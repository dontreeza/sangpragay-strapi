import * as fs from 'fs';
import * as path from 'path';
import createBuilder from '../schema-builder';
import { snakeCase } from 'lodash/fp';

type RenameObject = { oldName: string; newName: string };

export class MigrationBuilder {
  steps: Array<any>;

  constructor() {
    this.steps = [];
  }

  addRenameAttribute(uid: string, names: RenameObject): void {
    this.steps.push({
      action: 'renameAttribute',
      uid,
      names,
    });
  }

  addDeleteComponent(uid: string): void {
    this.steps.push({
      action: 'deleteComponent',
      uid,
    });
  }

  async writeFiles(outputDir?: string) {
    try {
      // Find or create the migrations directory
      const strapiDir = strapi.dirs.app?.root || process.cwd();
      const migrationsDir = outputDir || path.join(strapiDir, 'database', 'migrations');
      if (!fs.existsSync(migrationsDir)) {
        fs.mkdirSync(migrationsDir, { recursive: true });
      }
      const timestamp = new Date().toISOString().replace(/[-:TZ.]/g, '');
      // We could determine a clearer filename such as "_delete_my_component" based on the actions
      const fileName = `${timestamp}_migration.js`;
      const filePath = path.join(migrationsDir, fileName);

      // Generate the content for the up migration
      const upContent = this.steps
        .map((step) => {
          if (step.action === 'deleteComponent') {
            return this.generateDeleteComponentKnex(step.uid);
          }
          if (step.action === 'renameAttribute') {
            return this.generateRenameAttributeKnex(step.uid, step.names);
          }
          return '';
        })
        .filter(Boolean)
        .join('\n');

      // In the real version we would use templates with javascript or typescript as per project settings
      // We could write the templates only in typescript and then run a converter on it to avoid maintaining multiple templates
      const fileContent = `// Migration file generated by Strapi at ${new Date().toISOString()}
  
  module.exports = {
    async up(knex) {
      ${upContent}
    },
    async down(knex) {
      // if we eventually develop full migration coverage in the builder, in theory we could start supporting down migrations
    },
  };
  `;

      fs.writeFileSync(filePath, fileContent, 'utf-8');

      console.log(`Migration file written to: ${filePath}`);
    } catch (error) {
      console.error('Error writing migration files:', error);
    }
  }

  private generateRenameAttributeKnex(uid: string, names: RenameObject): string {
    const builder = createBuilder();

    // Find the table name for the content type
    const metadata = strapi.db.metadata.get(uid);
    if (!metadata) {
      throw new Error(`Content type with uid ${uid} not found.`);
    }

    const tableName = metadata.tableName;

    if (!tableName) {
      throw new Error(`Table name for content type ${uid} not found.`);
    }

    // Generate SQL for renaming the column
    // In real version, instead of snakeCase we would used Database.identifiers to get the true expected name of the table
    return `    await knex.schema.table('${tableName}', (table) => {
      table.renameColumn('${snakeCase(names.oldName)}', '${snakeCase(names.newName)}');
    });`;
  }

  // This returns the knex statements necessary for a delete components action
  // In this case, we loop through the content types and find references that will need
  // to be deleted and write them out as knex statements for the migration
  private generateDeleteComponentKnex(uid: string): string {
    const builder = createBuilder();

    const models = [...builder.contentTypes.entries(), ...builder.components.entries()];

    const deleteStatements: string[] = [];

    for (const [modelUid] of models) {
      const metadata = strapi.db.metadata.get(modelUid);

      const matchingAttributes = Object.values(metadata.attributes).filter(
        (attr: any) => attr.target === uid && attr.joinTable?.name
      );

      for (const attr of matchingAttributes) {
        if (!('joinTable' in attr && attr.joinTable && attr.joinTable.name)) {
          continue;
        }

        // Generate SQL for deleting entries from the join table
        const tableName = attr.joinTable.name;
        // In the real version, this would work better with templates
        deleteStatements.push(
          `    await knex('${tableName}').where('component_type', '${uid}').del();`
        );
      }
    }

    return deleteStatements.join('\n');
  }
}
